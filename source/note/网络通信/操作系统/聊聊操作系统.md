okay， 再回顾一下操作系统

 

1. 寄存器**是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的**控制部件**中，包含的寄存器有**指令寄存器(IR)**和**程序计数器(PC)。**在中央处理器的**算术及逻辑部件**中，包含的寄存器有**累加器(ACC)。

2. 内存包含的范围非常广，一般分为只读存储器（ROM）、随机存储器（RAM）和高速缓存存储器（cache）。

3. 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。
   
4. **Cache** ：**即高速缓冲存储器**，**是位于CPU与主内存间的一种容量较小但速度很高的存储器**。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，**Cache中保存着CPU刚用过或循环使用的一部分数据**，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。**Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部**，L2 Cache早期一般是焊在主板上,**现在也都集成在CPU内部**，常见的容量有256KB或512KB L2 Cache。



```
 1）找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）

（2）将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。

（3）将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。

（4）确定数据在哪一个内存块（chunk）上，从该块读取数据。

（5）数据先送回内存控制器，再送回CPU，然后开始使用。
```

```
Reading from a register looks like:

Extract the relevant bits from the instruction.
Put those bits onto the register file's read lines.
Read the result.
Reading from RAM looks like:

Get the pointer to the data being loaded. (Said pointer is probably in a register. This already encompasses all of the work done above!)
Send that pointer off to the MMU.
The MMU translates the virtual address in the pointer to a physical address.
Send the physical address to the memory controller.
Memory controller figures out what bank of RAM the data is in and asks the RAM.
The RAM figures out particular chunk the data is in, and asks that chunk.
Step 6 may repeat a couple of more times before narrowing it down to a single array of cells.
Load the data from the array.
Send it back to the memory controller.
Send it back to the CPU.
Use it!

```





## 五、内存模型：Heap

寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。

程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从`0x1000`到`0x8000`，起始地址是较小的那个地址，结束地址是较大的那个地址。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012208.png)

程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用`malloc`命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址`0x1000`开始给他分配，一直分配到地址`0x100A`，如果再要求得到22个字节，那么就分配到`0x1020`。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012209.png)

这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。

## 六、内存模型：Stack

除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png)

请看下面的例子。

> ```clike
> int main() {
>    int a = 2;
>    int b = 3;
> }
> ```

上面代码中，系统开始执行`main`函数时，会为它在内存里面建立一个帧（frame），所有`main`的内部变量（比如`a`和`b`）都保存在这个帧里面。`main`函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012211.png)

如果函数内部调用了其他函数，会发生什么情况？

> ```clike
> int main() {
>    int a = 2;
>    int b = 3;
>    return add_a_and_b(a, b);
> }
> ```

上面代码中，`main`函数内部调用了`add_a_and_b`函数。执行到这一行的时候，系统也会为`add_a_and_b`新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：`main`和`add_a_and_b`。一般来说，调用栈有多少层，就有多少帧。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012212.png)

等到`add_a_and_b`运行结束，它的帧就会被回收，系统会回到函数`main`刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。

所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做"入栈"，英文是 push；栈的回收叫做"出栈"，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做"后进先出"的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012213.jpg)

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012214.jpg)

Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是`0x8000`，第一帧假定是16字节，那么下一次分配的地址就会从`0x7FF0`开始；第二帧假定需要64字节，那么地址就会移动到`0x7FB0`。

![img](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012215.png)